import wavesurfer from './init.js';
import {
    selectedRegion
} from './init.js';
import {
    EQ_CELLO,
    EQ_PERCUSSION,
    GrainDefs_Perc,
    GrainDefs_Cello,
    GrainDefs_Mix_Default,
    RangeValues
} from './defs.js'

import wavesBasicControllers from 'waves-basic-controllers'; //wavesBasicControllers is an alias in webpack.config.json
import X2JS from './lib/xml2js.min.js';

const GRAIN_DEFAULT = GrainDefs_Mix_Default;
const EQ_DEFAULT = EQ_CELLO;


var x2js = new X2JS();

// Create elan instance
var elan = Object.create(wavesurfer.ELAN);

// Create Elan Wave Segment instance
var elanWaveSegment = Object.create(wavesurfer.ELANWaveSegment);
var wavesSegmentsArray = [];

var ELAN_ACTIONS = {
    'addselection': function() {
        var svg = $('#wijzer')[0];
        var matrix = svg.getScreenCTM()
                .translate(+svg.getAttribute("cx"),
                         +svg.getAttribute("cy"));



        var waveSegmentPos = {
            left:  (matrix.e) + "px",
            top: (matrix.f - 15) + "px", 
            width: svg.getAttribute('width')
        }

        wavesSegmentsArray.push(waveSegmentPos);
        console.log(wavesSegmentsArray);

        var wavesegment_options = {
            container: '#waveform',
            waveColor: '#3498db',
            progressColor: '#f1c40f',
            loaderColor: 'purple',
            cursorColor: '#e67e22',
            selectionColor: '#d0e9c6',
            backend: 'WebAudio',
            normalize: true,
            loopSelection: false,
            renderer: 'Canvas',
            waveSegmentRenderer: 'Canvas',
            waveSegmentHeight: 50,
            height: 100,
            barWidth: 2,
            plotTimeEnd: wavesurfer.backend.getDuration(),
            wavesurfer: wavesurfer,
            ELAN: elan,
            wavesSegmentsArray,
            scrollParent: false
        };

        
        console.log(selectedRegion);
        elan.addAnnotation(selectedRegion.start, selectedRegion.end, "Example Text", "Comment Test");
        elanWaveSegment.init(wavesegment_options);
    }
};


function playPause2() {

    console.log("DUMMMYYY");
}

    var wz_xs = [],
        wz_ymin = [],
        wz_ymax = [],
        bars = [];
var opt, onYouTubeIframeAPIReady, msc_credits, media_height, times_arr, offset_js, endtime_js, abc_arr, lpRec;
//Vim Vree - ABC Web
var muziek, curmtr, curtmp, msc_svgs, msc_gs, msc_wz, offset, mediaFnm, abcSave, elmed, scoreFnm, timerId = -1;
var ybplayer, yubchk = 0,
    pbrates = [],
    noprogress = 0,
    onYouTubeAPIContinue, opt_url = {},
    sok = null,
    gFac;
var /*dummyPlayer = new DummyPlayer (), */TOFF = 0.01;
opt = {}; // global options
function initGlobals() {
    abcSave = ''; // abc code:: [string]
    muziek = ''; // svg code generated by abc2svg
    curmtr = [0, 0, 0]; // current metre
    curtmp = [0, 0, 0]; // current tempo
    msc_svgs = [] // svg elements, one per line of music
    msc_gs = [] // top graphics elements <g></g> of all music lines
    msc_wz = null; // gobal cursor object
    offset = 0.0; // offset: time in media file where music starts
    gFac = 0.1; // absolute change for offset or duration
    noprogress = 0; // stop cursor until offset synced
}


function dolayout(abctxt) {
    var muziek = '',
        errtxt = '',
        abc2svg, bxs = {},
        bys = {},
        xleft, times = [],
        nxs = [],
        mtxts = [];
    var BAR = 0,
        METER = 6,
        NOTE = 8,
        REST = 10,
        TEMPO = 14,
        BASE_LEN = 1536,
        tixbts = [],
        mbeats = [],
        mreps = [],
        mdurs = [];
    var tixlb = [
        [0, 0, 1]
    ]; // time index -> [line_num, bar_num, repcnt], line_num == 0.., bar_num == 1.., repcnt = 1..
    var lbtix = []; // line_num, bar_num, repcnt -> time index
    function errmsg(txt, line, col) {
        errtxt += txt + '\n';
    }

    function keySort(d) {
        var keys = Object.keys(d).map(function f(x) {
            return parseFloat(x);
        });
        keys.sort(function f(a, b) {
            return a - b;
        }); // numerical sort
        return keys;
    }

    function img_out(str) {
        if (str.indexOf('<svg') != -1) {
            str = str.replace(/width="(\d*)px"\s*height="(\d*)px"/, 'width="$1px" height="$2px" viewbox="0 0 $1 $2"');
            bxs = keySort(bxs), bys = keySort(bys);
            if (bxs.length > 1 && // the first barline is at bxs[1] because bxs[0] == left side staff
                bxs[1] < Math.min.apply(null, nxs)) { // first barline < min x-coor of all notes in this line
                bxs.splice(0, 1); // remove left side staff because there already is a left barline
            }
            bars.push({
                'xs': bxs,
                'ys': bys
            });
            bxs = {}, bys = {}, nxs = [];
        }
        muziek += str;
    }

    function svgInfo(type, s1, s2, x, y, w, h) {
        if (type == 'note' || type == 'rest') nxs.push(abc2svg.sx(x)); // x-coor of notes/rests for left barline check
        if (type == 'bar') {
            x = abc2svg.sx(x).toFixed(2);
            y = abc2svg.sy(y).toFixed(2);
            bxs[x] = 1, bys[y] = 1;
            xleft = abc2svg.sx(0).toFixed(2);
            bxs[xleft] = 1;
        }
    }

    function getTune(abctxt) {
        var ts, t, abc_lines, i, ro;
        abctxt = abctxt.replace(/\r\n/g, '\n'); // \r\n matches /^$/ ==> each line would get an extra empty line!!!
        ts = abctxt.split(/^\s*X:/m); // split on X:, multi line search
        if (ts.length == 1) return []; // no X:
        t = ts[1].split(/^\s*$/m); // split on empty lines
        t = ts[0] + 'X:' + t[0]; // header + first tune
        abc_lines = t.split(/\r\n|[\n\r\u0085\u2028\u2029]/); // whoppa
        for (i = 0; i < Math.min(100, abc_lines.length); ++i) {
            ro = abc_lines[i].match(/%%scale\s*([\d.]+)/); // avoid %%scale 1.0, because different svg hierarchy
            if (ro && ro[1] == 1.0) abc_lines[i] = '%%scale 0.99';
        }
        console.log(abc_lines);
        return abc_lines;
    }

    function timeLine(ts_p, voice_tb, music_types) {
        console.log("TIMELINE!");
        var ts, g, ftempo = 384 * 120 / 60,
            dtmp, mdur = 0,
            mt = 0,
            nbeat, lbtm = 0; // quarter duration 384, tempo 120
        try {
            nbeat = voice_tb[0].meter.a_meter[0].top;
        } // first voice, first meter: {top: x, bot: y}
        catch (e) {
            nbeat = '4';
        } // no meter defined in abc
        for (ts = ts_p; ts; ts = ts.ts_next) {
            if (ts.v != 0) continue; // skip voices > 0
            for (g = ts.extra; g; g = g.next) {
                if (g.type == TEMPO && g.tempo_notes) {
                    dtmp = g.tempo_notes.reduce(function(sum, x) {
                        return sum + x;
                    });
                    ftempo = dtmp * g.tempo / 60;
                }
            }
            switch (ts.type) {
                case NOTE:
                case REST:
                    mdur += ts.dur / ftempo;
                    break;
                case BAR:
                    ~console.log('bar_type: ' + ts.bar_type + ' text: ' + ts.text);
                    if (ts.time == lbtm) {
                        mreps[mreps.length - 1] += ts.bar_type;
                        break;
                    } // concatenate left bar with previous
                    if ('eoln' in ts) lbtm = ts.time; // to detect left bar at start of line
                    mdurs.push(mdur);
                    mdur = 0;
                    nbeat = nbeat.replace('C|', '2').replace('C', '4');
                    mbeats.push(parseInt(nbeat)); // array of beats per measure
                    mreps.push(ts.bar_type);
                    mtxts.push(ts.text);
                    break;
                case METER:
                    nbeat = ts.a_meter[0].top;
                    break;
            }
        }
        console.log(mdurs);
    }

    function perc2map(abcIn) {
        var b = '%%beginsvg\n<defs>\n'
        b += '<text id="x" x="-3" y="0">&#xe263;</text>\n'
        b += '<text id="normal" x="-3.7" y="0">&#xe0a4;</text>\n'
        b += '<g id="circle-x"><text x="-3" y="0">&#xe263;</text><circle r="4" class="stroke"/></g>\n'
        b += '<path id="triangle" d="m-4 -3.2l4 6.4 4 -6.4z" class="stroke" style="stroke-width:1.4"/>\n'
        b += '<path id="triangle+" d="m-4 -3.2l4 6.4 4 -6.4z" class="stroke" style="fill:#000"/>\n'
        b += '<path id="rectangle" d="m-3.5 3l0 -6.2 7.2 0 0 6.2z" class="stroke" style="stroke-width:1.4"/>\n'
        b += '<path id="rectangle+" d="m-3.5 3l0 -6.2 7.2 0 0 6.2z" class="stroke" style="fill:#000"/>\n'
        b += '<path id="diamond" d="m0 -3l4.2 3.2 -4.2 3.2 -4.2 -3.2z" class="stroke" style="stroke-width:1.4"/>\n'
        b += '<path id="diamond+" d="m0 -3l4.2 3.2 -4.2 3.2 -4.2 -3.2z" class="stroke" style="fill:#000"/>\n'
        b += '</defs>\n%%endsvg'
        var fillmap = {
            'diamond': 1,
            'triangle': 1,
            'rectangle': 1
        };
        var abc = [b],
            ls, i, x, r, id = 'default',
            maps = {
                'default': []
            };
        ls = abcIn.split('\n');
        for (i = 0; i < ls.length; ++i) {
            x = ls[i];
            if (x.indexOf('I:percmap') >= 0) {
                x = x.split(' ');
                var kop = x[4];
                if (kop in fillmap) kop = kop + '+' + ',' + kop;
                x = '%%map perc' + id + ' ' + x[1] + ' print=' + x[2] + ' midi=' + x[3] + ' heads=' + kop;
                maps[id].push(x);
            }
            if (x.indexOf('V:') >= 0) {
                r = x.match(/V:\s*(\S+)/);
                if (r) {
                    id = r[1];
                    if (!(id in maps)) maps[id] = [];
                }
            }
        }
        for (id in maps) abc = abc.concat(maps[id]);
        for (i = 0; i < ls.length; ++i) {
            x = ls[i];
            if (x.indexOf('I:percmap') >= 0) continue;
            if (x.indexOf('V:') >= 0 || x.indexOf('K:') >= 0) {
                r = x.match(/V:\s*(\S+)/);
                if (r) id = r[1];
                if (maps[id].length == 0) id = 'default';
                abc.push(x);
                if (x.indexOf('perc') >= 0 && x.indexOf('map=') == -1) x += ' map=perc';
                if (x.indexOf('map=perc') >= 0 && maps[id].length > 0) abc.push('%%voicemap perc' + id);
                if (x.indexOf('map=off') >= 0) abc.push('%%voicemap');
            } else abc.push(x);
        }
        return abc.join('\n');
    }

    function compPlayMap() {
        var line = 0, // (system) line index: 0..,
            ibar = 1, // measure index on line: 1..
            nbars = bars[line].xs.length, // number of measures on this line
            mix = 0, // total measure index: mix = 0.., total time index: tix = 1..
            pbtime = 0, // play back time
            reptix = 1, // total time index of start of repeat    (count includes repeats)
            repmix = 0, // total measure index of start of repeat (count excludes repeats)
            repcnt = 1, // 2 in second traversal
            volta = 0; // 1..
       // console.log(mtxts);
        console.log("FIXME: Handle situaion when repeat bar is like this | : ... :| .... :|, instead of  | : ... :|: .... :|");
        //While go into infinite loop in the case above!!!!!!
        while (1) {
            console.log("Bars: " + bars.length + " line " + line);
            var v = mtxts[mix - 1]; // volta is on the previous measure
            var r = v ? v.match(/[,\d]*(\d)/) : null; // last int is highest volta num
            if (r) {
                v = parseInt(r[1]);
                if (v != volta) volta = v; // volta lasts until next volta
            }
            if (!volta || volta >= repcnt) // skip when repcnt > volta num
            {
                pbtime += mdurs[mix];
                times.push(pbtime);
                tixbts.push(mbeats[mix]); // also unfold beats for metronome and count-in
                if (!lbtix[line]) lbtix[line] = [];
                if (!lbtix[line][ibar]) lbtix[line][ibar] = [];
                lbtix[line][ibar][repcnt] = tixlb.length;
                tixlb.push([line, ibar, repcnt]);
            }
            if (mreps[mix] != '|') volta = 0; // reset on any special bar line
            var r = /^:/.test(mreps[mix]);
            if (r && repcnt == 1 && !opt.repskip) { // jump to start of repeat
                repcnt = 2; // now second play
                mix = repmix;
                ibar = tixlb[reptix][1]; // bar index on this line
                line = tixlb[reptix][0]; // line index
                nbars = bars[line].xs.length; // number of measures on this line
            } else {
                if (r) repcnt = 1; // reset repcount
                if (/:$/.test(mreps[mix])) { // define start of repeat
                    reptix = tixlb.length;
                    repmix = mix + 1;
                    repcnt = 1; // first play
                }
                mix += 1; // go to next measure
                ibar += 1;
                if (ibar >= nbars) { // measure is on next line
                    ibar = 1; // first bar index on this line
                    line += 1; // next line
                    if (line >= bars.length) break; // end of part
                    nbars = bars[line].xs.length; // number of measures on this line
                }
            }
        }
    }
    initGlobals();
    var score = $('#notation');
    $('body').attr('title', '') // clear drag/drop help message
    score.html(''); // clear notation area
    var abc_lines = getTune(abctxt);
    abctxt = abc_lines.join('\n');
    if (abctxt.indexOf('percmap') >= 0) abctxt = perc2map(abctxt);
    var user = {
        'img_out': img_out,
        'errmsg': errmsg,
        'read_file': function(x) {
            return '';
        }, // %%abc-include, unused
        'anno_start': svgInfo,
        'get_abcmodel': timeLine
    }
    abc2svg = new Abc(user);
    abc2svg.tosvg('abc2svg', abctxt);
    if (errtxt != '') $('#err').append(errtxt);
    score.html(muziek);
    msc_svgs = score.find('svg'); // all music lines
    msc_svgs.css('overflow', 'visible');
    msc_svgs.children('title').text(''); // avoid title popup's
    var gs = msc_svgs.children('g'); // only the topmost g per svg
    for (var i = 0; i < gs.length; ++i) {
        msc_gs.push(gs.eq(i));
    }
    /*var wz_xs = [],
        wz_ymin = [],
        wz_ymax = [];*/
    for (var i = 0; i < bars.length; ++i) { // i = line number
        var bs = bars[i]; // bars of line i
        wz_xs[i] = bs.xs; // x coors of bars
        wz_ymin[i] = bs.ys[0]; // min, max y coor of bar
        wz_ymax[i] = bs.ys[bs.ys.length - 1];
    }
    compPlayMap();
    /*~console.log('times: ' + times);
    ~console.log('tixbts: ' + tixbts);
    ~console.log('mreps: ' + mreps);
    ~console.log('mtxts: ' + mtxts);
    ~console.log('tixlb: ' + JSON.stringify(tixlb));
    ~console.log('lbtix: ' + JSON.stringify(lbtix));
    ~console.log('len times: ' + times.length + ' len tixlb: ' + tixlb.length)*/

    if (typeof(times_arr) != 'undefined') { // external timings take precedence.
        times = flattenTimes(times_arr); // make 1d array of times
    }
    if (typeof(offset_js) != 'undefined') {
        offset = offset_js; // external offset
    }

    if (typeof(endtime_js) != 'undefined') { // scale times to given end time
        var durnew = endtime_js - offset; // duration of score in seconds
        var durold = times[times.length - 1]; // first time is always 0
        times = times.map(function(t) {
            return t * durnew / durold
        });
    }
    abcSave = abc_lines; // keep in global for saving
    //msc_wz = new Wijzer(wz_xs, wz_ymin, wz_ymax, times, tixlb, lbtix, tixbts);
    //console.log(msc_wz);
    //msc_wz.setline(1);
    msc_svgs.each(function() {
       $(this).mousedown(klik);
    }); // each music line gets the click handler
    //if (!elmed) elmed = dummyPlayer;
    //var play_start = lpRec.loopStart + offset + TOFF;       // account for loopStart
    //setTimeout (function () {                               // wait on DOM rendering ready (slow video!)
    //    playPause ('false:' + play_start + ':false', 0);    // position at start, no count_in, no delay
    //    setLoop ();
    //}, 0);


}

function klik (evt) {       // mousedown on svg
    evt.preventDefault ();
    evt.stopPropagation();
    var line = msc_svgs.get().indexOf (this);   // index of the clicked svg
    var x = evt.clientX;    // position click relative to page
    x -= $(this).position ().left;  // minus (position left edge if svg relative to page)
    x2time (x, line);
}

function x2time (x, line) {

    function isBigEnough(element) {
      return element >= x;
    }

    // Get the sfaff measure number from an X-value;
    var measure = bars[line].xs.findIndex(isBigEnough)-1; 
    var measure_width = bars[line].xs[measure+1] - bars[line].xs[measure];

    console.log ("X: "+ x +" , " + "measure: "+ measure +" width: " +measure_width);
    //this.setx (0, 0, 0);    // hide cursor at start
    //this.line = line;
    //this.wijzer.prependTo (msc_gs [line]);  // insert cursor in target music line
    var width = msc_svgs [line].width.baseVal.value;
    var cursor = Wijzer (line, bars[line].xs[measure], measure_width);
    $('#wijzer').remove (); // take away cursor from where it was
    cursor.prependTo (msc_gs [line]);

}

function Wijzer (line, x, width) {  // create the music cursor

    var wijzer = $(document.createElementNS ('http://www.w3.org/2000/svg','svg'));
    wijzer.attr ('id', 'wijzer');
    wijzer.css ('overflow','visible');
    var shade = $(document.createElementNS ('http://www.w3.org/2000/svg','rect'));
    shade.attr ({width:'100%', height:'100%'});
    wijzer.append (shade);
    var tiktak = $(document.createElementNS ('http://www.w3.org/2000/svg','text'));
    tiktak.attr ('y', 5);
    tiktak.css ({fill:'green', stroke:'green', 'text-anchor':'end', 'font-size':'xx-large'});
    wijzer.append (tiktak);
    var atag =  $(document.createElementNS ('http://www.w3.org/2000/svg','text'));
    atag.attr ('id', 'atag'); atag.text ('<');
    atag.css ({fill:'red', stroke:'red', 'text-anchor':'middle'});
    var btag =  $(document.createElementNS ('http://www.w3.org/2000/svg','text'));
    btag.attr ('id', 'btag'); btag.text ('>');
    btag.css ({fill:'red', stroke:'red', 'text-anchor':'middle'});

    wijzer.attr ('x', (x+10).toFixed (2));
    wijzer.attr ('width', width.toFixed (2));
    shade.attr ('fill-opacity', 0.2);
    shade.attr('fill', "#3498db");

    return wijzer;

}   

var setupGrain = function(GrainDefs) {
    var container = document.querySelector('#granular-engine-container');
    container.innerHTML = "";

    var self = wavesurfer.backend;

    /* Initialize granular engine and draw slider */
    for (var k in GrainDefs) {
        //console.log(RangeValues[k]);
        if (typeof RangeValues[k] !== 'undefined') {
            //console.log("Key: " + k);
            var value = GrainDefs[k];
            self.transportedGranularEngine[k] = value;

            // Curry function. Probably better ways to
            // setup up the granular sliders, but can't 
            // figure it out at the moment.
            var sliderFactory = function(k) {
                return function(val) {
                    new wavesBasicControllers.Slider(k, RangeValues[k].min, RangeValues[k].max, 0.0001, value, "", '', container, function(val) {
                        if (k === 'speed') {
                            self.playControl.speed = val;
                        } else {
                            self.transportedGranularEngine[k] = val;
                        }
                    });

                };
            };

            var makeSlider = sliderFactory(k);
            makeSlider(value);


            //console.log("Key is " + k + ", value is" + self.transportedGranularEngine[k]);
        }
    }


}
var setupEQ = function(EQ) {
    // Create filters
    var filters = EQ.map(function(band) {
        var filter = wavesurfer.backend.ac.createBiquadFilter();
        filter.type = band.type;
        filter.gain.value = band.value;
        filter.Q.value = 1;
        filter.frequency.value = band.f;
        return filter;
    });

    // Bind filters to vertical range sliders
    var container = document.querySelector('#granular-engine-pitch-container');
    container.innerHTML = "";
    filters.forEach(function(filter, index) {
        var input = document.createElement('input');
        wavesurfer.util.extend(input, {
            type: 'range',
            min: -40,
            max: 40,
            value: filter.gain.value,
            title: filter.frequency.value
        });
        input.style.display = 'inline-block';
        input.setAttribute('orient', 'vertical');
        wavesurfer.drawer.style(input, {
            'webkitAppearance': 'slider-vertical',
            width: '40px',
            height: '150px'
        });

        var div = document.createElement('div');
        div.style.display = 'inline-block';
        div.innerHTML = '<p style="width:18px;max-width:8px;" id="EQ_' + index + '_title">' + filter.frequency.value + '</p>';
        var div2 = document.createElement('div');
        //div2.style.display = 'inline-block';
        div2.innerHTML = '<p style="width:18px;max-width:8px;" id="EQ_' + index + '">' + filter.gain.value + '</p>';

        div.appendChild(input);
        div.appendChild(div2);
        container.appendChild(div);

        var onChange = function(e) {
            filter.gain.value = ~~e.target.value;
            var el = document.querySelector('#EQ_' + index);
            el.innerHTML = filter.gain.value;

        };

        input.addEventListener('input', onChange);
        input.addEventListener('change', onChange);
    });

    /* LIMITER */
    var hardLimiter = wavesurfer.backend.ac.createDynamicsCompressor();
    hardLimiter.threshold.value = -10.0; // this is the pitfall, leave some headroom
    hardLimiter.knee.value = 0.0; // brute force
    hardLimiter.ratio.value = 20.0; // max compression
    hardLimiter.attack.value = 0.005; // 5ms attack
    hardLimiter.release.value = 0.50; // 50ms release

    filters.push(hardLimiter);
    // Connect filters to wavesurfer
    wavesurfer.backend.setFilters(filters);

    // For debugging
    wavesurfer.filters = filters;

}

var setupDropdowns = function(e) {
    $("#EQ_string_preset").click(function(e) {
        //do something
        console.log("Loading string preset...");
        setupEQ(EQ_CELLO);

        e.preventDefault();
    });

    $("#EQ_percussion_preset").click(function(e) {
        //do something
        console.log("Loading percussion preset...");
        setupEQ(EQ_PERCUSSION);
        e.preventDefault();
    });

    $("#Grain_string_preset").click(function(e) {
        //do something
        console.log("Loading string preset...");

        setupGrain(GrainDefs_Cello);
        e.preventDefault();
    });

    $("#Grain_percussion_preset").click(function(e) {
        //do something
        console.log("Loading percussion preset...");
        setupGrain(GrainDefs_Perc);
        e.preventDefault();
    });

}

var setupReverb = function() {
    var reverbGain;
    var audioContext = wavesurfer.backend.getAudioContext();
    reverbjs.extend(audioContext);
    // 2) Load the impulse response; upon load, connect it to the audio output.
    //var reverbUrl = "http://reverbjs.org/Library/KinoullAisle.m4a";
    var reverbUrl = "https://rawgit.com/burnson/Reverb.js/master/Library/TyndallBruceMonument.m4a";
    var reverbNode = audioContext.createReverbFromUrl(reverbUrl, function() {
        reverbGain = wavesurfer.backend.ac.createGain();
        reverbGain.gain.value = 0.15;

        reverbGain.connect(audioContext.destination);
        reverbNode.connect(reverbGain);
        wavesurfer.backend.gainNode.connect(reverbNode);
    });
}

//wavesurfer.on('ready', function() {
document.addEventListener('DOMContentLoaded', function() {

    /* ELAN */
    elan.on('select', function(start, end) {
        wavesurfer.backend.play(start, end);
    });

    //set up listener for when elan is done
    elan.on('ready', function(data) {
        //go load the wave form
        //wavesurfer.load('./transcripts/001z.mp3');

        //add some styling to elan table
        var classList = elan.container.querySelector('table').classList;
        ['table', 'table-striped', 'table-hover'].forEach(function(cl) {
            classList.add(cl);
        });
    });


    //Setup Elan actions
    [].forEach.call(document.querySelectorAll('[data-action]'), function(el) {
        el.addEventListener('click', function(e) {
            var action = e.currentTarget.dataset.action;
            if (action in ELAN_ACTIONS) {
                e.preventDefault();
                ELAN_ACTIONS[action](e);
            }
        });
    });


    //LOAD ELAN

    function loadXMLDoc(dname) {
        var xhttp;
        if (window.XMLHttpRequest) {
            xhttp = new XMLHttpRequest();
        } else {
            xhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        xhttp.open("GET", dname, false);
        xhttp.send();
        return xhttp.responseXML;
    }


    //init elan
    elan.init({
        //url: './transcripts/001z.xml',
        container: '#annotations',
        tiers: {
            Text: true,
            Comments: true
        }
    });


    var xmlDoc = loadXMLDoc("./transcripts/elan_template.xml");
    var x2js = new X2JS();
    var jsonObj = x2js.xml2json(xmlDoc);
    var str = JSON.stringify(jsonObj, null, 2); // spacing level = 2
    //console.log(str);

    elan.loadJson(jsonObj);

    wavesurfer.on('ready', function() {
        wavesurfer.clearRegions();

        // Regions
        if (wavesurfer.enableDragSelection) {
            wavesurfer.enableDragSelection({
                color: 'rgba(41, 128, 185, 0.25)'
            });
        }

        //Setup some basic hooks
        setupDropdowns();
        setupGrain(GRAIN_DEFAULT);
        setupEQ(EQ_DEFAULT);
        setupReverb();

        //LOAD ABC TUNE

        endtime_js = wavesurfer.getDuration();
        console.log(endtime_js);
        // read text from URL location
        var request = new XMLHttpRequest();
        request.open('GET', './assets/tune.abc', true);
        request.send(null);
        request.onreadystatechange = function() {

            if (request.readyState === 4 && request.status === 200) {
                var type = request.getResponseHeader('Content-Type');
                if (type.indexOf("text") !== 1) {
                    dolayout(request.responseText);
                    return request.responseText;
                }
            }
        }


    });



    var prevAnnotation, prevRow, region;
    var onProgress = function(time) {
        elanWaveSegment.onProgress(time);
        var annotation = elan.getRenderedAnnotation(time);

        if (prevAnnotation != annotation) {
            prevAnnotation = annotation;

            region && region.remove();
            region = null;

            if (annotation) {
                // Highlight annotation table row
                var row = elan.getAnnotationNode(annotation);
                prevRow && prevRow.classList.remove('success');
                prevRow = row;
                row.classList.add('success');
                var before = row.previousSibling;
                if (before) {
                    elan.container.scrollTop = before.offsetTop;
                }

                // Region
                region = wavesurfer.addRegion({
                    start: annotation.start,
                    end: annotation.end,
                    resize: false,
                    color: 'rgba(223, 240, 216, 0.7)'
                });
            }
        }
    };

    wavesurfer.on('audioprocess', onProgress);


});